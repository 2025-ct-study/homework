# 문제 풀이

### 소프티어 출퇴근길

- 어떤 정점 X가 출퇴근길 모두에 포함되려면:
    1. S -> X 경로 존재해야 함
    2. X -> T 경로 존재해야 함
    3. T -> X 경로 존재해야 함
    4. X -> S 경로 존재해야 함

</br>

### 소프티어 나무 조경

1. 격자 내 모든 위치에서 탐색 시작
2. 현재 위치 (i, j)에서 상하좌우로 이동하며 쌍을 만든 후 dfs 수행
3. 방문 여부를 확인하여 이미 쌍을 이룬 나무는 고려하지 않음
4. count가 4가 되면 아름다움 합 갱신

</br>

### 소프티어 약속 시간

</br>

### 소프티어 탑의 높이

</br>

### 백준 1987 알파벳

- 'dfs + 백트래킹'으로 풀면 시간 초과 발생 <br>
=> 해결) `set`을 이용해 중복된 경로 탐색을 방지 & 알파벳 개수(26개)로 탐색 제한

</>

### 백준 2206 벽 부수고 이동하기

- 방문 여부를 3차원 배열로 관리 
    - `visited[x][y][0]` -> 벽 안 부숨 
    - `visited[x][y][1]` -> 벽 한 번 부숨

</br>

### 백준 9466 텀 프로젝트

- `team += cycle[cycle.index(next):]` 를 통해 사이클이 되는 노드부터 팀을 이루도록 함

</br>

### 백준 7576 토마토

- 토마토가 익을 때마다 `tomatoes[x][y]` 에 익는 날짜를 기록<br>
    : 결과 출력 시, `-1` 필요

</br>

### 백준 4179 불!

- 소프티어 '나무 섭지' 문제와 유사함
- 지훈이와 불 모두 이동 가능한 칸의 경우, 지훈이의 소요시간이 더 적어야만 탈출 가능

</br>

### 프로그래머스 네트워크

- 백준 '연결 요소의 개수' 문제와 유사함
- 새로운 dfs를 호출할 때, 네트워크 개수를 1 증가시켜야 함