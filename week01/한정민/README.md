# 문제 풀이

### 프로그래머스 N으로 표현

- dp[i] : N을 i번 사용하여 만들 수 있는 숫자들의 집합

1. N을 i번 사용하여 만들 수 있는 수는 `N을 j번 사용하여 만들 수 있는 수 (사칙연산) N을 i-j번 사용하여 만들 수 있는 수` 로 나타낼 수 있다.

   - 예를 들어, N을 4번 사용하여 만들 수 있는 수는 아래와 같다.

   1. N을 1번 사용하여 만들 수 있는 수 (사칙연산) N을 3번 사용하여 만들 수 있는 수
   2. N을 2번 사용하여 만들 수 있는 수 (사칙연산) N을 2번 사용하여 만들 수 있는 수
   3. N을 3번 사용하여 만들 수 있는 수 (사칙연산) N을 1번 사용하여 만들 수 있는 수

2. number가 dp[i]에 있으면 i를, 없으면 -1을 반환한다.

</br>

### 백준 2156 포도주 시식

1. glasses[i]를 기준으로 세가지 경우로 나눈다.
   1. glasses[i]를 마시지 않는 경우
   2. glasses[i]를 마시고, glasses[i-1]을 마시지 않은 경우
   3. glasses[i]와 glasses[i-1]을 모두 마시는 경우

2. 구한 dp 중 최댓값을 출력한다.

</br>

### 프로그래머스 도넛과 막대 그래프

1. edges를 돌며 그래프를 만들고, 그래프를 만들면서 in_degree에 각 노드의 들어오는 간선 개수를 저장한다.
2. 들어오는 간선 개수가 0이고, 연결된 간선 개수가 2개 이상인 노드를 찾는다.
3. new_node(생성된 정점)와 연결된 노드들을 DFS하며 각 그래프의 노드와 간선 개수를 계산한다.
4. 노드와 간선의 개수를 비교하여 그래프 모양을 확인한다.
   1. 노드 개수 == 간선 개수 -> 도넛 모양
   2. 노드 개수 - 1 == 간선 개수 -> 막대 모양
   3. 노드 개수 + 1 == 간선 개수 -> 팔자 모양양

</br>

### 소프티어 X marks the Spot

1. 문자열 S를 소문자로 변환하여 'x'의 인덱스를 찾는다.
2. 위에서 찾은 인덱스를 활용하여 문자열 T의 해당 위치의 문자를 추출한다.
3. 추출한 문자를 대문자로 변환하여 결과 리스트에 추가한다.

</br>

### 백준 11722 가장 긴 감소하는 부분 수열

- dp[i] : 수열의 i번째 숫자를 마지막으로 하는 '가장 긴 감소하는 부분 수열'의 길이
1. i번째 숫자를 기준으로 이전의 숫자들(j)을 확인한다.
2. data[j] > data[i] 이면, j번째 숫자 뒤에 i번째 숫자를 붙일 수 있으므로 수열의 길이는 `dp[j] + 1`이다.
3. 이 값을 현재 `dp[i]`와 비교하여 큰 값으로 갱신한다. 

</br>

### 백준 12865 평범한 배낭

- dp[n+1][k+1]
1. 2중 for문을 통해 배열 dp를 돌며 아래 알고리즘을 수행한다.
2. 현재의 가방 용량과 짐 무게에 따라 경우를 나눈다.
   1. 가방 용량(j) <ㅠ 무게(weight)인 경우 : [이전 물건(i-1)][같은 무게(j)] 값을 넣어준다.

        `dp[i][j] = dp[i-1][j]`

   2. 가방 용량(j) > 무게(weight)인 경우 : 아래 두 값 중 큰 값을 넣어준다.
        
        a) 현재 추가하는 물건의 가치(value)를 이전 물건의 가치에 더하고, 추가하는 물건의 무게(weight)만큼 뺀 값

        b) [이전 물건(i-1)][같은 무게(j)] 값
        
        `dp[i][j] = max(dp[i-1][j-weight] + value, dp[i-1][j])`
3. 배열의 마지막에 저장된 값 `(dp[n][k])` 을 반환한다.

</br>

### 백준 15486 퇴사 2

- dp[i] : i일까지 얻을 수 있는 최대 수익
1. dp[i-1]과 비교하여 i일의 최댓값을 갱신한다 + i일에 시작하는 상담 종료일(i+t-1일)의 최댓값도 갱신한다.
2. 마지막 날짜의 수익값을 출력한다.

</br>

### 백준 1149 RGB거리

- dp[i][j] : i번째 집에 j번째 색을 칠했을 경우의 최소 비용
1. 첫번째 집을 칠하는 경우는 각각의 비용과 동일하게 설정한다.
2. 두번째 집부터는 이전 집에서 현재 색과 다른 색을 칠한 2가지 경우를 비교하여 최솟값을 구한다.
3. 마지막 집의 dp값 중 최솟값을 출력한다.

</br>

### 프로그래머스 스티커 모으기(2)

- dp1 : 첫번째 스티커를 떼어 낸 경우 -> 마지막 스티커 제외
- dp2 : 첫번째 스티커를 떼지 않은 경우 -> 마지막 스티커까지 계산

</br>

### 백준 11052 카드 구매하기

- dp[i] : i개의 카드를 구매했을 때, 지불해야 하는 금액의 최댓값