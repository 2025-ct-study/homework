# 문제 풀이

### 프로그래머스 N으로 표현

- dp[i] : N을 i번 사용하여 만들 수 있는 숫자들의 집합

1. N을 i번 사용하여 만들 수 있는 수는 `N을 j번 사용하여 만들 수 있는 수 (사칙연산) N을 i-j번 사용하여 만들 수 있는 수` 로 나타낼 수 있다.

   - 예를 들어, N을 4번 사용하여 만들 수 있는 수는 아래와 같다.

   1. N을 1번 사용하여 만들 수 있는 수 (사칙연산) N을 3번 사용하여 만들 수 있는 수
   2. N을 2번 사용하여 만들 수 있는 수 (사칙연산) N을 2번 사용하여 만들 수 있는 수
   3. N을 3번 사용하여 만들 수 있는 수 (사칙연산) N을 1번 사용하여 만들 수 있는 수

2. number가 dp[i]에 있으면 i를, 없으면 -1을 반환한다.

</br>

### 백준 2156 포도주 시식

1. glasses[i]를 기준으로 세가지 경우로 나눈다.
   1. glasses[i]를 마시지 않는 경우
   2. glasses[i]를 마시고, glasses[i-1]을 마시지 않은 경우
   3. glasses[i]와 glasses[i-1]을 모두 마시는 경우

2. 구한 dp 중 최댓값을 출력한다.

</br>

### 프로그래머스 도넛과 막대 그래프

1. edges를 돌며 그래프를 만들고, 그래프를 만들면서 in_degree에 각 노드의 들어오는 간선 개수를 저장한다.
2. 들어오는 간선 개수가 0이고, 연결된 간선 개수가 2개 이상인 노드를 찾는다.
3. new_node(생성된 정점)와 연결된 노드들을 DFS하며 각 그래프의 노드와 간선 개수를 계산한다.
4. 노드와 간선의 개수를 비교하여 그래프 모양을 확인한다.
   1. 노드 개수 == 간선 개수 -> 도넛 모양
   2. 노드 개수 - 1 == 간선 개수 -> 막대 모양
   3. 노드 개수 + 1 == 간선 개수 -> 팔자 모양양

</br>

### 소프티어 X marks the Spot

1. 문자열 S를 소문자로 변환하여 'x'의 인덱스를 찾는다.
2. 위에서 찾은 인덱스를 활용하여 문자열 T의 해당 위치의 문자를 추출한다.
3. 추출한 문자를 대문자로 변환하여 결과 리스트에 추가한다.
