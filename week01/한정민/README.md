# 문제 풀이

### 프로그래머스 N으로 표현

- dp[i] : N을 i번 사용하여 만들 수 있는 숫자들의 집합

1. N을 i번 사용하여 만들 수 있는 수는 `N을 j번 사용하여 만들 수 있는 수 (사칙연산) N을 i-j번 사용하여 만들 수 있는 수` 로 나타낼 수 있다.

   - 예를 들어, N을 4번 사용하여 만들 수 있는 수는 아래와 같다.

   1. N을 1번 사용하여 만들 수 있는 수 (사칙연산) N을 3번 사용하여 만들 수 있는 수
   2. N을 2번 사용하여 만들 수 있는 수 (사칙연산) N을 2번 사용하여 만들 수 있는 수
   3. N을 3번 사용하여 만들 수 있는 수 (사칙연산) N을 1번 사용하여 만들 수 있는 수

2. number가 dp[i]에 있으면 i를, 없으면 -1을 반환한다.

</br>

### 백준 2156 포도주 시식

1. glasses[i]를 기준으로 세가지 경우로 나눈다.
   1. glasses[i]를 마시지 않는 경우
   2. glasses[i]를 마시고, glasses[i-1]을 마시지 않은 경우
   3. glasses[i]와 glasses[i-1]을 모두 마시는 경우

2. 구한 dp 중 최댓값을 출력한다.

</br>

### 프로그래머스 도넛과 막대 그래프

1. edges를 돌며 그래프를 만들고, 그래프를 만들면서 in_degree에 각 노드의 들어오는 간선 개수를 저장한다.
2. 들어오는 간선 개수가 0이고, 연결된 간선 개수가 2개 이상인 노드를 찾는다.
3. new_node(생성된 정점)와 연결된 노드들을 DFS하며 각 그래프의 노드와 간선 개수를 계산한다.
4. 노드와 간선의 개수를 비교하여 그래프 모양을 확인한다.
   1. 노드 개수 == 간선 개수 -> 도넛 모양
   2. 노드 개수 - 1 == 간선 개수 -> 막대 모양
   3. 노드 개수 + 1 == 간선 개수 -> 팔자 모양양

</br>

### 소프티어 X marks the Spot

1. 문자열 S를 소문자로 변환하여 'x'의 인덱스를 찾는다.
2. 위에서 찾은 인덱스를 활용하여 문자열 T의 해당 위치의 문자를 추출한다.
3. 추출한 문자를 대문자로 변환하여 결과 리스트에 추가한다.

</br>

### 백준 11722 가장 긴 감소하는 부분 수열

- dp[i] : 수열의 i번째 숫자를 마지막으로 하는 '가장 긴 감소하는 부분 수열'의 길이
1. i번째 숫자를 기준으로 이전의 숫자들(j)을 확인한다.
2. data[j] > data[i] 이면, j번째 숫자 뒤에 i번째 숫자를 붙일 수 있으므로 수열의 길이는 `dp[j] + 1`이다.
3. 이 값을 현재 `dp[i]`와 비교하여 큰 값으로 갱신한다. 

</br>

### 백준 12865 평범한 배낭

- dp[n+1][k+1]
1. 2중 for문을 통해 배열 dp를 돌며 아래 알고리즘을 수행한다.
2. 현재의 가방 용량과 짐 무게에 따라 경우를 나눈다.
   1. 가방 용량(j) < 무게(weight)인 경우 : [이전 물건(i-1)][같은 무게(j)] 값을 넣어준다.

        `dp[i][j] = dp[i-1][j]`

   2. 가방 용량(j) > 무게(weight)인 경우 : 아래 두 값 중 큰 값을 넣어준다.
        
        a) 현재 추가하는 물건의 가치(value)를 이전 물건의 가치에 더하고, 추가하는 물건의 무게(weight)만큼 뺀 값

        b) [이전 물건(i-1)][같은 무게(j)] 값
        
        `dp[i][j] = max(dp[i-1][j-weight] + value, dp[i-1][j])`
3. 배열의 마지막에 저장된 값 `(dp[n][k])` 을 반환한다.

