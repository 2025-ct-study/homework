# ▶숙제

### BOJ 2529 부등호
- 백트랙킹: 0~9 사이의 숫자를 순서대로 추가
- 숫자 추가 시, 아래 조건 확인
  - 방문한 적 없는 수 인지
  - 부등호 조건에 맞는 수 인지
- 끝(N+1)까지 도달하면, 최대/최소 값 갱신

### BOJ 17298 오큰수
- 이중 탐색 시 시간초과 발생 
  - 스택을 사용하여 개선 
  - 스택: 오큰수를 찾아야하는 수(인덱스)를 담는 용도, 처음엔 비어있음
- 배열을 차례대로 탐색 (for)
  - 스택이 비어있지 않고, 현재 탐색하는 수가 스택에 있는 수 보다 크면 (while)
    - 현재 탐색하는 수는 스택에 있는 수의 오큰수
    - 오큰수를 찾았으니 스택에서 pop
  - 현재 탐색하는 수 스택에 추가
- 배열 전체 탐색 후, 스택에 남아있는 수는 오큰수를 찾지 못한 수 이므로 -1 처리

### BOJ 16500 문자열 판별
- dp를 사용하여 판별
  - 문자열 끝에서부터 한칸씩 순착적으로 이동하며 탐색
  - `dp[i]`: i 인덱스부터의 문자열이 단어목록으로 만들어질 수 있으면 1, 없으면 0
  - 문자열 끝에 쉽게 접근하기 위해 dp 길이를 `s.length()+1`로 지정하고 마지막에 1을 할당해준다.
- i부터 시작하는 문자열이 단어 목록으로 만들어지는지 판별하는 방법
  - 시작 인덱스 i 기준, `뒤에 있는 단어들의 앞` or `문자열의 끝`을 끝 인덱스로 하는 서브 문자열이 단어목록에 있는지 판별 
  - 즉, i 뒤에 있는 dp[j] = 1인 j를 끝 인덱스로 하는 서브 문자열이 단어목록에 포함되면 가능

### 

### 

### 

### 

### 
